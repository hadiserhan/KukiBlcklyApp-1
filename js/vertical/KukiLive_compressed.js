// Do not edit this file; automatically generated by build.py.
"use strict";

"use strict";
Blockly.KukiLive = new Blockly.Generator("KukiLive");
Blockly.KukiLive.addReservedWords(
  "False,None,True,and,as,assert,break,class,continue,def,del,elif,else,except,exec,finally,for,from,global,if,import,in,is,lambda,nonlocal,not,or,pass,print,raise,return,try,while,with,yield,NotImplemented,Ellipsis,__debug__,quit,exit,copyright,license,credits,ArithmeticError,AssertionError,AttributeError,BaseException,BlockingIOError,BrokenPipeError,BufferError,BytesWarning,ChildProcessError,ConnectionAbortedError,ConnectionError,ConnectionRefusedError,ConnectionResetError,DeprecationWarning,EOFError,Ellipsis,EnvironmentError,Exception,FileExistsError,FileNotFoundError,FloatingPointError,FutureWarning,GeneratorExit,IOError,ImportError,ImportWarning,IndentationError,IndexError,InterruptedError,IsADirectoryError,KeyError,KeyboardInterrupt,LookupError,MemoryError,ModuleNotFoundError,NameError,NotADirectoryError,NotImplemented,NotImplementedError,OSError,OverflowError,PendingDeprecationWarning,PermissionError,ProcessLookupError,RecursionError,ReferenceError,ResourceWarning,RuntimeError,RuntimeWarning,StandardError,StopAsyncIteration,StopIteration,SyntaxError,SyntaxWarning,SystemError,SystemExit,TabError,TimeoutError,TypeError,UnboundLocalError,UnicodeDecodeError,UnicodeEncodeError,UnicodeError,UnicodeTranslateError,UnicodeWarning,UserWarning,ValueError,Warning,ZeroDivisionError,_,__build_class__,__debug__,__doc__,__import__,__loader__,__name__,__package__,__spec__,abs,all,any,apply,ascii,basestring,bin,bool,buffer,bytearray,bytes,callable,chr,classmethod,cmp,coerce,compile,complex,copyright,credits,delattr,dict,dir,divmod,enumerate,eval,exec,execfile,exit,file,filter,float,format,frozenset,getattr,globals,hasattr,hash,help,hex,id,input,int,intern,isinstance,issubclass,iter,len,license,list,locals,long,map,max,memoryview,min,next,object,oct,open,ord,pow,print,property,quit,range,raw_input,reduce,reload,repr,reversed,round,set,setattr,slice,sorted,staticmethod,str,sum,super,tuple,type,unichr,unicode,vars,xrange,zip"
);
Blockly.KukiLive.ORDER_ATOMIC = 0;
Blockly.KukiLive.ORDER_COLLECTION = 1;
Blockly.KukiLive.ORDER_STRING_CONVERSION = 1;
Blockly.KukiLive.ORDER_MEMBER = 2.1;
Blockly.KukiLive.ORDER_FUNCTION_CALL = 2.2;
Blockly.KukiLive.ORDER_EXPONENTIATION = 3;
Blockly.KukiLive.ORDER_UNARY_SIGN = 4;
Blockly.KukiLive.ORDER_BITWISE_NOT = 4;
Blockly.KukiLive.ORDER_MULTIPLICATIVE = 5;
Blockly.KukiLive.ORDER_ADDITIVE = 6;
Blockly.KukiLive.ORDER_BITWISE_SHIFT = 7;
Blockly.KukiLive.ORDER_BITWISE_AND = 8;
Blockly.KukiLive.ORDER_BITWISE_XOR = 9;
Blockly.KukiLive.ORDER_BITWISE_OR = 10;
Blockly.KukiLive.ORDER_RELATIONAL = 11;
Blockly.KukiLive.ORDER_LOGICAL_NOT = 12;
Blockly.KukiLive.ORDER_LOGICAL_AND = 13;
Blockly.KukiLive.ORDER_LOGICAL_OR = 14;
Blockly.KukiLive.ORDER_CONDITIONAL = 15;
Blockly.KukiLive.ORDER_LAMBDA = 16;
Blockly.KukiLive.ORDER_NONE = 99;
Blockly.KukiLive.ORDER_OVERRIDES = [
  [Blockly.KukiLive.ORDER_FUNCTION_CALL, Blockly.KukiLive.ORDER_MEMBER],
  [Blockly.KukiLive.ORDER_FUNCTION_CALL, Blockly.KukiLive.ORDER_FUNCTION_CALL],
  [Blockly.KukiLive.ORDER_MEMBER, Blockly.KukiLive.ORDER_MEMBER],
  [Blockly.KukiLive.ORDER_MEMBER, Blockly.KukiLive.ORDER_FUNCTION_CALL],
  [Blockly.KukiLive.ORDER_LOGICAL_NOT, Blockly.KukiLive.ORDER_LOGICAL_NOT],
  [Blockly.KukiLive.ORDER_LOGICAL_AND, Blockly.KukiLive.ORDER_LOGICAL_AND],
  [Blockly.KukiLive.ORDER_LOGICAL_OR, Blockly.KukiLive.ORDER_LOGICAL_OR],
];
Blockly.KukiLive.init = function (a) {
  Blockly.KukiLive.PASS = this.INDENT + "pass\n";
  Blockly.KukiLive.definitions_ = Object.create(null);
  Blockly.KukiLive.functionNames_ = Object.create(null);
  Blockly.KukiLive.variableDB_
    ? Blockly.KukiLive.variableDB_.reset()
    : (Blockly.KukiLive.variableDB_ = new Blockly.Names(
        Blockly.KukiLive.RESERVED_WORDS_
      ));
  Blockly.KukiLive.variableDB_.setVariableMap(a.getVariableMap());
  a = [];
  var b = "";
  Blockly.KukiLive.definitions_.varNames = [];
  for (
    var c = Blockly.KukiLive.variableDB_.variableMap_.getAllVariables(), d = 0;
    d < c.length;
    d++
  )
    (a[d] = "u" + d + " = 0"),
      (b = b + "u" + d + ","),
      (Blockly.KukiLive.definitions_.varNames[d] = c[d].name);
  Blockly.KukiLive.definitions_.variables = a.join("\n");
  Blockly.KukiLive.definitions_.internalVariables = "";
  Blockly.KukiLive.definitions_.MotorDistUnits = "seconds";
  Blockly.KukiLive.definitions_.currentIndent = "";
  Blockly.KukiLive.definitions_.driving = !1;
  Blockly.KukiLive.definitions_.lineTrackOn = !1;
  Blockly.KukiLive.definitions_.nextNoteSharp = !1;
  Blockly.KukiLive.definitions_.MusicUsed = !1;
  Blockly.KukiLive.definitions_.obsEventUnused = !0;
  Blockly.KukiLive.definitions_.loopVar = 0;
  Blockly.KukiLive.definitions_.inMusicBackGround = !1;
  Blockly.KukiLive.definitions_.musicStackFlag = !1;
  Blockly.KukiLive.definitions_.musicStackString = "";
  Blockly.KukiLive.definitions_.globalVarsDict = {};
  Blockly.KukiLive.definitions_.Header ="";
  Blockly.KukiLive.definitions_.distanceSetUp = "";
  Blockly.KukiLive.definitions_.tempoSetUp = "";
  Blockly.KukiLive.definitions_.globalVars = "";
  b != "" &&
    (Blockly.KukiLive.definitions_.globalVars =
      "global " + b.substring(0, b.length - 1) + "\n");
};
Blockly.KukiLive.finish = function (a) {
  for (var b in Blockly.KukiLive.definitions_.globalVarsDict);
  // Blockly.KukiLive.definitions_.Header =
    // Blockly.KukiLive.definitions_.Header +
    // Blockly.KukiLive.definitions_.distanceSetUp +
    // "\n" +
    // Blockly.KukiLive.definitions_.tempoSetUp +
    // "\n#---------user Vars----------------\n" +
    // Blockly.KukiLive.definitions_.variables +
    // "\n#---------gerated code-------------\n";
  a = Blockly.KukiLive.definitions_.Header + a;
  delete Blockly.KukiLive.definitions_;
  delete Blockly.KukiLive.functionNames_;
  Blockly.KukiLive.variableDB_.reset();
  return a;
};
Blockly.KukiLive.scrubNakedValue = function (a) {
  return a + "\n";
};
Blockly.KukiLive.quote_ = function (a) {
  a = a.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/%/g, "\\%");
  var b = "'";
  a.indexOf("'") !== -1 &&
    (a.indexOf('"') === -1 ? (b = '"') : (a = a.replace(/'/g, "\\'")));
  return b + a + b;
};
Blockly.KukiLive.scrub_ = function (a, b) {
  var c = "";
  if (!a.outputConnection || !a.outputConnection.targetConnection) {
    var d = a.getCommentText();
    (d = Blockly.utils.wrap(d, Blockly.KukiLive.COMMENT_WRAP - 3)) &&
      (c = a.getProcedureDef
        ? c + ('"""' + d + '\n"""\n')
        : c + Blockly.KukiLive.prefixLines(d + "\n", "# "));
    for (var e = 0; e < a.inputList.length; e++)
      a.inputList[e].type == Blockly.INPUT_VALUE &&
        (d = a.inputList[e].connection.targetBlock()) &&
        (d = Blockly.KukiLive.allNestedComments(d)) &&
        (c += Blockly.KukiLive.prefixLines(d, "# "));
  }
  a = a.nextConnection && a.nextConnection.targetBlock();
  a = Blockly.KukiLive.blockToCode(a);
  return c + b + a;
};
Blockly.KukiLive.emptyOrCommentOnly = function (a) {
  if (a == "") return !0;
  a = a.split("\n");
  for (var b = 0; b < a.length; b++) {
    var c = a[b].trimStart();
    if (!c.startsWith("#") && c != "") return !1;
  }
  return !0;
};
Blockly.KukiLive.getAdjustedInt = function (a, b, c, d) {
  c = c || 0;
  a.workspace.options.oneBasedIndex && c--;
  var e = a.workspace.options.oneBasedIndex ? "1" : "0";
  a =
    Blockly.KukiLive.valueToCode(
      a,
      b,
      c ? Blockly.KukiLive.ORDER_ADDITIVE : Blockly.KukiLive.ORDER_NONE
    ) || e;
  Blockly.isNumber(a)
    ? ((a = parseInt(a, 10) + c), d && (a = -a))
    : ((a =
        c > 0
          ? "int(" + a + " + " + c + ")"
          : c < 0
          ? "int(" + a + " - " + -c + ")"
          : "int(" + a + ")"),
      d && (a = "-" + a));
  return a;
};

//! HADI CODE:
//*STARTS EVENTS
Blockly.KukiLive.event = {};
Blockly.KukiLive.event_whenflagclicked =function (a) {
    return ("FF 55 EE 00 00 00 00-");
};
Blockly.KukiLive.event_wait_seconds =function (a) {
  var value = Blockly.KukiLive.valueToCode(a, "DURATION", Blockly.KukiLive.ORDER_ATOMIC);
  if(value > 65534){
    value = 65534;
  }
  var result = toTwoByteHex(parseInt(value));
  return ("FF 55 01 00 " + result.low + " " + result.high + " 00-");
};
Blockly.KukiLive.event_wait_until_button_pressed =function (a) {
   return ("FF 55 01 01 00 00 00-");
};
Blockly.KukiLive.event_stopAll =function (a) {
   return ("FF 55 DD 00 00 00 00-");
};
//* END EVENTS
//!-----------------------------------------------
//*STARTS CONTROL
Blockly.KukiLive.control = {};
Blockly.KukiLive.control_repeat =function (a) {
    var value = Blockly.KukiLive.valueToCode(a, "TIMES", Blockly.KukiLive.ORDER_ATOMIC);
    if(value > 65534){
      value = 65534;
    }
    Blockly.KukiLive.definitions_.loopVar += 1;
    var loopCount = Blockly.KukiLive.definitions_.loopVar;
    loopCount = toTwoByteHex(parseInt(loopCount));

    var result = toTwoByteHex(parseInt(value));
    var branch = Blockly.KukiLive.statementToCode(a, 'SUBSTACK');
    branch = Blockly.KukiLive.addLoopTrap(branch, a);
    var end_loop = "FF 55 01 05 " + loopCount.low + " 00 00-";
    var loop = "FF 55 01 02 " + loopCount.low + " " + result.low + " " + result.high + "-"
    return (loop + branch + end_loop);
};
Blockly.KukiLive.control_forever = function (a) {
  var value = Blockly.KukiLive.valueToCode(a, "TIMES", Blockly.KukiLive.ORDER_ATOMIC);
  if(value > 65534){
    value = 65534;
  }
  Blockly.KukiLive.definitions_.loopVar += 1;
  var loopCount = Blockly.KukiLive.definitions_.loopVar;
  loopCount = toTwoByteHex(parseInt(loopCount));

  var result = toTwoByteHex(parseInt(value));
  var branch = Blockly.KukiLive.statementToCode(a, 'SUBSTACK');
  branch = Blockly.KukiLive.addLoopTrap(branch, a);
  var end_loop = "FF 55 01 05 " + loopCount.low + " 00 00-";
  var loop = "FF 55 01 02 " + loopCount.low + " " + result.low + " " + result.high + "-"
  return (loop + branch + end_loop);
};
//* END CONTROL
//!-----------------------------------------------
//*STARTS MOTION
Blockly.KukiLive.motion = {};
Blockly.KukiLive.motion_set_speed = function (block) {
  var speed = block.getFieldValue('SPEED');
  var result = toTwoByteHex(parseInt(speed));
  return ("FF 55 08 00 " + result.low + " " + result.high + " 00-");
}
//* END MOTION
//!-----------------------------------------------
Blockly.KukiLive.Advanced = {};
Blockly.KukiLive.Advanced_usb_received_data = function (a) {
  return ["Ed.ReadUSB()", Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.Advanced_usb_received_data_variable = function (a) {
  a = Blockly.KukiLive.valueToCode(a, "VARIABLE", Blockly.KukiLive.ORDER_ATOMIC);
  return (
    "#wait until data received from USB\n" +
    a +
    "=Ed.ReadUSB()\nwhile " +
    a +
    "==None:\n\t" +
    a +
    "=Ed.ReadUSB()\n"
  );
};
Blockly.KukiLive.Advanced_usb_send_data = function (a) {
  return (
    "#send data via USB\nEd.WriteUSB(" +
    Blockly.KukiLive.valueToCode(a, "DATA", Blockly.KukiLive.ORDER_ATOMIC) +
    ")\n"
  );
};
Blockly.KukiLive.Comment = {};
Blockly.KukiLive.Comment_userComment = function (a) {
  return "#User comment line, text not included for obvious reasons\n";
};
Blockly.KukiLive.Control = {};
Blockly.KukiLive.control_if = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "CONDITION",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.statementToCode(a, "SUBSTACK");
  Blockly.KukiLive.emptyOrCommentOnly(a) && (a = "\tpass\n");
  return "#if condition \nif " + b + ":\n" + a;
};
Blockly.KukiLive.control_if_else = function (a) {
  var b = Blockly.KukiLive.valueToCode(
      a,
      "CONDITION",
      Blockly.KukiLive.ORDER_ATOMIC
    ),
    c = Blockly.KukiLive.statementToCode(a, "SUBSTACK");
  a = Blockly.KukiLive.statementToCode(a, "SUBSTACK2");
  Blockly.KukiLive.emptyOrCommentOnly(c) && (c = "\tpass\n");
  Blockly.KukiLive.emptyOrCommentOnly(a) && (a = "\tpass\n");
  return "#if condition \nif " + b + ":\n" + c + "else:\n" + a;
};
Blockly.KukiLive.control_wait = function (a) {
  var b = "#wait for time\n";
  a = Blockly.KukiLive.valueToCode(a, "DURATION", Blockly.KukiLive.ORDER_ATOMIC);
  a = isNaN(Number(a)) ? "(" + a + "*1000)" : a * 1e3;
  return (b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.TimeWait(" +
    a +
    ",Ed.TIME_MILLISECONDS)\n");
};
Blockly.KukiLive.control_wait_until = function (a) {
  return (
    "#wait for condition\nwhile not (" +
    Blockly.KukiLive.valueToCode(a, "CONDITION", Blockly.KukiLive.ORDER_ATOMIC) +
    "):\n\tpass\n"
  );
};
Blockly.KukiLive.control_repeat_until = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "CONDITION",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.statementToCode(a, "SUBSTACK");
  Blockly.KukiLive.emptyOrCommentOnly(a) && (a = "\tpass\n");
  return "#loop until condition \nwhile not (" + b + "):\n" + a;
};
Blockly.KukiLive.control_wait_milliseconds = function (a) {
  var b = "#wait for time\n";
  a = Blockly.KukiLive.valueToCode(a, "DURATION", Blockly.KukiLive.ORDER_ATOMIC);
  if (a == "" || a == "Infinity") a = 0;
  return (b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.TimeWait(" +
    a +
    ",Ed.TIME_MILLISECONDS)\n");
};
Blockly.KukiLive.dropdown_control_setloop_event = function (a) {
  a = a.getFieldValue("CHOICE");
  return [
    a == "circle"
      ? "Ed.ReadKeypad() != Ed.KEYPAD_ROUND"
      : "Ed.ReadKeypad() != Ed.KEYPAD_TRIANGLE",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.control_loop_event = function (a) {
  var b = Blockly.KukiLive.valueToCode(a, "CHOICE", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.statementToCode(a, "SUBSTACK");
  a == "" && (a = "\tpass\n");
  return "#loop until button \nwhile " + b + ":\n" + a;
};
Blockly.KukiLive.control_loop_event_obstacle = function (a) {
  var b = Blockly.KukiLive.definitions_.inObsLoop;
  Blockly.KukiLive.definitions_.inObsLoop = !0;
  a = Blockly.KukiLive.statementToCode(a, "SUBSTACK");
  Blockly.KukiLive.definitions_.inObsLoop = b;
  a == "" && (a = "\tpass\n");
  b = "";
  Blockly.KukiLive.definitions_.inObsLoop == 0 &&
    (b = "Ed.ObstacleDetectionBeam(Ed.OFF)\n");
  return (
    "#loop until obs \nEd.ObstacleDetectionBeam(Ed.ON)\nwhile Ed.ReadObstacleDetection() <= Ed.OBSTACLE_NONE:\n" +
    a +
    b
  );
};
Blockly.KukiLive.control_stop = function (a) {
  return "#end of code \n";
};
Blockly.KukiLive.dropdown_control_setwait_event = function (a) {
  a = a.getFieldValue("CHOICE");
  switch (a) {
    case "clap":
      a = "Ed.ReadClapSensor()!=Ed.CLAP_DETECTED";
      break;
    case "circle":
      a = "Ed.ReadKeypad()!=Ed.KEYPAD_ROUND";
      break;
    case "triangle":
      a = "Ed.ReadKeypad()!=Ed.KEYPAD_TRIANGLE";
      break;
    case "black":
      a = "Ed.ReadLineState()!=Ed.LINE_ON_BLACK";
      Blockly.KukiLive.definitions_.lineTrackOn ||
        ((Blockly.KukiLive.definitions_.lineTrackOn = !0),
        (Blockly.KukiLive.definitions_.Header += "Ed.LineTrackerLed(Ed.ON)\n"));
      break;
    case "white":
      a = "Ed.ReadLineState()!=Ed.LINE_ON_WHITE";
      Blockly.KukiLive.definitions_.lineTrackOn == 0 &&
        ((Blockly.KukiLive.definitions_.lineTrackOn = !0),
        (Blockly.KukiLive.definitions_.Header += "Ed.LineTrackerLed(Ed.ON)\n"));
      break;
    case "left":
      a = "Ed.ReadLeftLightLevel()<=Ed.ReadRightLightLevel()";
      break;
    case "right":
      a = "Ed.ReadLeftLightLevel()>=Ed.ReadRightLightLevel()";
  }
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.control_wait_event = function (a) {
  var b = "#wait until event \n";
  a = Blockly.KukiLive.valueToCode(a, "CHOICE", Blockly.KukiLive.ORDER_ATOMIC);
  return a == "clapTwo"
    ? b +
        "noClaps=True\nEd.ReadClapSensor()\nwhile noClaps:\n\twhile Ed.ReadClapSensor()!=Ed.CLAP_DETECTED:\n\t\tpass\n\tEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadClapSensor()\n\tEd.TimeWait(350, Ed.TIME_MILLISECONDS)\n\tif Ed.ReadClapSensor()==Ed.CLAP_DETECTED:\n\t\tnoClaps=False\n"
    : b + "while " + a + ":\n\tpass\n";
};
Blockly.KukiLive.control_wait_event_obstacle = function (a) {
  a = "";
  Blockly.KukiLive.definitions_.inObsLoop == 0 &&
    (a = "Ed.ObstacleDetectionBeam(Ed.OFF)\n");
  return (
    "#wait until obstacle \nEd.ObstacleDetectionBeam(Ed.ON)\nwhile Ed.ReadObstacleDetection() != Ed.OBSTACLE_AHEAD:\n\tpass\n" +
    a
  );
};
Blockly.KukiLive.dropdown_control_setwait_message = function (a) {
  return [a.getFieldValue("CHOICE"), Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.control_wait_message = function (a) {
  return (
    "#wait until message \nwhile Ed.ReadIRData()!=" +
    Blockly.KukiLive.valueToCode(a, "CHOICE", Blockly.KukiLive.ORDER_ATOMIC) +
    ":\n\tpass\n"
  );
};
Blockly.KukiLive.dropdown_control_set_message = function (a) {
  return [a.getFieldValue("CHOICE"), Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.control_send_message = function (a) {
  return (
    "#send message \nEd.SendIRData(" +
    Blockly.KukiLive.valueToCode(a, "CHOICE", Blockly.KukiLive.ORDER_ATOMIC) +
    ")\n"
  );
};
Blockly.KukiLive.Data = {};
Blockly.KukiLive.data_variable = function (a) {
  var b = Blockly.KukiLive.variableDB_.getName(
    a.getFieldValue("VARIABLE"),
    Blockly.Variables.NAME_TYPE
  );
  b = Blockly.KukiLive.definitions_.varNames.indexOf(b);
  b == -1 && (b = 0);
  b = "u" + b;
  a = a.getRootBlock().type;
  a != "event_Start" &&
    a.includes("event_") &&
    Blockly.KukiLive.definitions_.globalVarsDict[a].indexOf(b) == -1 &&
    Blockly.KukiLive.definitions_.globalVarsDict[a].push(b);
  return [b, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.data_setvariableto = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "VARIABLE",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "VALUE", Blockly.KukiLive.ORDER_ATOMIC);
  return "#set variable \n" + b + " = " + a + "\n";
};
Blockly.KukiLive.data_incvariable = function (a) {
  return (
    "#inc variable \n" +
    Blockly.KukiLive.valueToCode(a, "VARIABLE", Blockly.KukiLive.ORDER_ATOMIC) +
    "+= 1\n"
  );
};
Blockly.KukiLive.data_decvariable = function (a) {
  return (
    "#dec variable \n" +
    Blockly.KukiLive.valueToCode(a, "VARIABLE", Blockly.KukiLive.ORDER_ATOMIC) +
    "-= 1 \n"
  );
};
Blockly.KukiLive.data_bitShiftLeft = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "VARIABLE",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "VALUE", Blockly.KukiLive.ORDER_ATOMIC);
  return "#bit shift variable \n" + b + " = " + b + " << " + a + ";\n";
};
Blockly.KukiLive.data_bitShiftRight = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "VARIABLE",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "VALUE", Blockly.KukiLive.ORDER_ATOMIC);
  return "#bit shift variable \n" + b + " = " + b + " >> " + a + ";\n";
};
Blockly.KukiLive.Drive = {};
Blockly.KukiLive.drive_speed_menu = function (a) {
  return [a.getFieldValue("SPEED_MENU"), Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.drive_forwards_distance = function (a) {
  var b = "#drive forwards for distance\n",
    c = Blockly.KukiLive.valueToCode(a, "DISTANCE", Blockly.KukiLive.ORDER_ATOMIC),
    d = a.getFieldValue("UNITS");
  d == "Ed.TIME"
    ? (c = isNaN(Number(c)) ? "(" + c + "*1000)" : c * 1e3)
    : isNaN(Number(c)) ||
      c % 1 == 0 ||
      ((c =
        d == "Ed.CM" ? Math.round(c / 0.125) : Math.round(c / (1.25 / 25.4))),
      (d = "Ed.TICKS"));
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.DistanceUnits =" +
    d +
    "\n";
  return (b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.Drive(Ed.FORWARD," +
    a +
    ", " +
    c +
    ")\n");
};
Blockly.KukiLive.drive_backwards_distance = function (a) {
  var b = "#drive backwards for distance\n",
    c = Blockly.KukiLive.valueToCode(a, "DISTANCE", Blockly.KukiLive.ORDER_ATOMIC),
    d = a.getFieldValue("UNITS");
  d == "Ed.TIME"
    ? (c = isNaN(Number(c)) ? "(" + c + "*1000)" : c * 1e3)
    : isNaN(Number(c)) || (c < 0.5 && (c = 1), (c = Math.round(c)));
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.DistanceUnits =" +
    d +
    "\n";
  return (b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.Drive(Ed.BACKWARD," +
    a +
    ", " +
    c +
    ")\n");
};
Blockly.KukiLive.drive_left_distance = function (a) {
  var b = "#drive left for distance\n",
    c = a.getFieldValue("DIRECTION");
  c += "_LEFT";
  var d = Blockly.KukiLive.valueToCode(
      a,
      "DISTANCE",
      Blockly.KukiLive.ORDER_ATOMIC
    ),
    e = a.getFieldValue("UNITS");
  e == "Ed.TIME"
    ? (d = isNaN(Number(d)) ? "(" + d + "*1000)" : d * 1e3)
    : isNaN(Number(d)) || (d < 0.5 && (d = 1), (d = Math.round(d)));
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.DistanceUnits =" +
    e +
    "\n";
  return (b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.Drive(" +
    c +
    "," +
    a +
    "," +
    d +
    ")\n");
};
Blockly.KukiLive.drive_right_distance = function (a) {
  var b = "#drive right for distance\n",
    c = a.getFieldValue("DIRECTION");
  c += "_RIGHT";
  var d = Blockly.KukiLive.valueToCode(
      a,
      "DISTANCE",
      Blockly.KukiLive.ORDER_ATOMIC
    ),
    e = a.getFieldValue("UNITS");
  e == "Ed.TIME"
    ? (d = isNaN(Number(d)) ? "(" + d + "*1000)" : d * 1e3)
    : isNaN(Number(d)) || (d < 0.5 && (d = 1), (d = Math.round(d)));
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.DistanceUnits =" +
    e +
    "\n";
  return (b =
    b +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.Drive(" +
    c +
    "," +
    a +
    "," +
    d +
    ")\n");
};
Blockly.KukiLive.drive_forwards_until = function (a) {
  var b = "#drive forwards until\n",
    c = Blockly.KukiLive.valueToCode(a, "WHILE", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  var d = Blockly.KukiLive.definitions_.currentIndent;
  return (
    b +
    d +
    "Ed.Drive(Ed.FORWARD, " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n" +
    d +
    "while not " +
    c +
    ":\n" +
    d +
    "\tpass\n" +
    d +
    "Ed.Drive(Ed.STOP, 0, 0);\n"
  );
};
Blockly.KukiLive.drive_backwards_until = function (a) {
  var b = "#drive backward until\n",
    c = Blockly.KukiLive.valueToCode(a, "WHILE", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  var d = Blockly.KukiLive.definitions_.currentIndent;
  return (
    b +
    d +
    "Ed.Drive(Ed.BACKWARD, " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n" +
    d +
    "while not " +
    c +
    ":\n" +
    d +
    "\tpass\n" +
    d +
    "Ed.Drive(Ed.STOP, 0, 0);\n"
  );
};
Blockly.KukiLive.drive_left_until = function (a) {
  var b = "#drive left until\n",
    c = a.getFieldValue("DIRECTION");
  c += "_LEFT";
  var d = Blockly.KukiLive.valueToCode(a, "WHILE", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  var e = Blockly.KukiLive.definitions_.currentIndent;
  return (
    b +
    e +
    "Ed.Drive(" +
    c +
    ", " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n" +
    e +
    "while not " +
    d +
    ":\n" +
    e +
    "\tpass\n" +
    e +
    "Ed.Drive(Ed.STOP, 0, 0);\n"
  );
};
Blockly.KukiLive.drive_right_until = function (a) {
  var b = "#drive right until\n",
    c = a.getFieldValue("DIRECTION");
  c += "_RIGHT";
  var d = Blockly.KukiLive.valueToCode(a, "WHILE", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  var e = Blockly.KukiLive.definitions_.currentIndent;
  return (
    b +
    e +
    "Ed.Drive(" +
    c +
    ", " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n" +
    e +
    "while not " +
    d +
    ":\n" +
    e +
    "\tpass\n" +
    e +
    "Ed.Drive(Ed.STOP, 0, 0);\n"
  );
};
Blockly.KukiLive.drive_set_left_motor = function (a) {
  var b = a.getFieldValue("DIRECTION");
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  return (
    "#set left motor\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.DriveLeftMotor(" +
    b +
    ", " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n"
  );
};
Blockly.KukiLive.drive_set_right_motor = function (a) {
  var b = a.getFieldValue("DIRECTION");
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  return (
    "#set right motor\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.DriveRightMotor(" +
    b +
    ", " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n"
  );
};
Blockly.KukiLive.drive_set_both_motor = function (a) {
  var b = a.getFieldValue("DIRECTION");
  a = Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  return (
    "#set right motor\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.Drive(" +
    b +
    ", " +
    a +
    ", Ed.DISTANCE_UNLIMITED)\n"
  );
};
Blockly.KukiLive.drive_stop = function (a) {
  var b = a.getFieldValue("MOTOR");
  Blockly.KukiLive.valueToCode(a, "SPEED", Blockly.KukiLive.ORDER_ATOMIC);
  return (
    "#All AHEAD HALT\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    b +
    "(Ed.STOP, 0, 0);\n"
  );
};
Blockly.KukiLive.dropdown_drive_setleft_event = function (a) {
  a = a.getFieldValue("CHOICE");
  return [driveDropDownToBool(a), Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.drive_left_event = function (a) {
  checkForDriveSpeedVar();
  var b = "#drive left while Event\n";
  a = Blockly.KukiLive.valueToCode(a, "CHOICE", Blockly.KukiLive.ORDER_ATOMIC);
  var c = Blockly.KukiLive.definitions_.currentIndent;
  b =
    b +
    c +
    "Ed.Drive(Ed.FORWARD_LEFT, ED_DRIVE_SPEED, Ed.DISTANCE_UNLIMITED)\n";
  a != "infinite" &&
    (b =
      b +
      c +
      "while " +
      a +
      ":\n" +
      c +
      "\tpass\n" +
      c +
      "Ed.Drive(Ed.STOP, 0, 0);\n");
  return b;
};
Blockly.KukiLive.Events = {};
Blockly.KukiLive.event_Start = function (a) {
  Blockly.KukiLive.definitions_.nextNoteSharp = !1;
  return "#start blocks \n";
};
Blockly.KukiLive.event_AnyObstacle = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_OBSTACLE_ANY, 'if1')\n#obstacle detected event \ndef if1():\n\tEd.RegisterEventHandler(Ed.EVENT_OBSTACLE_ANY, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadObstacleDetection()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_ObstacleAhead = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_OBSTACLE_AHEAD, 'if2')\n#obstacle detected event \ndef if2():\n\tEd.RegisterEventHandler(Ed.EVENT_OBSTACLE_AHEAD, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadObstacleDetection()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_ObstacleLeft = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_OBSTACLE_LEFT, 'if3')\n#obstacle detected event \ndef if3():\n\tEd.RegisterEventHandler(Ed.EVENT_OBSTACLE_LEFT, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadObstacleDetection()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_ObstacleRight = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_OBSTACLE_RIGHT, 'if4')\n#obstacle detected event \ndef if4():\n\tEd.RegisterEventHandler(Ed.EVENT_OBSTACLE_RIGHT, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadObstacleDetection()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_clap = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_CLAP_DETECTED, 'if5')\n#new clap event \ndef if5():\n\tEd.RegisterEventHandler(Ed.EVENT_CLAP_DETECTED, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadClapSensor()\n\t#clap one event\n" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_TriangleButton = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_KEYPAD_TRIANGLE, 'if6')\n#triangle button event  \ndef if6():\n\tEd.RegisterEventHandler(Ed.EVENT_KEYPAD_TRIANGLE, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadKeypad()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_RoundButton = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_KEYPAD_ROUND, 'if7')\n#circle button event  \ndef if7():\n\tEd.RegisterEventHandler(Ed.EVENT_KEYPAD_ROUND, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadKeypad()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_LineReflective = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_LINE_TRACKER_ON_WHITE, 'if8')\n#Line on white event   \ndef if8():\n\tEd.RegisterEventHandler(Ed.EVENT_LINE_TRACKER_ON_WHITE, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadLineState()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_LineNonReflective = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_LINE_TRACKER_ON_BLACK, 'if9')\n#Line on black event   \ndef if9():\n\tEd.RegisterEventHandler(Ed.EVENT_LINE_TRACKER_ON_BLACK, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadLineState()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_LineChange = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_LINE_TRACKER_SURFACE_CHANGE, 'if10')\n#Line change event   \ndef if10():\n\tEd.RegisterEventHandler(Ed.EVENT_LINE_TRACKER_SURFACE_CHANGE, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadLineState()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_Message = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  Blockly.KukiLive.definitions_.nextNoteSharp = !1;
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_IR_DATA, 'if11')\n#new message event \ndef if11():\n\tEd.RegisterEventHandler(Ed.EVENT_IR_DATA, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadIRData()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_Remote = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  Blockly.KukiLive.definitions_.nextNoteSharp = !1;
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_REMOTE_CODE, 'if12')\n#new remote event \ndef if12():\n\tEd.RegisterEventHandler(Ed.EVENT_REMOTE_CODE, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadRemote()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.event_DriveStrain = function (a) {
  Blockly.KukiLive.definitions_.globalVarsDict[a.type] = [];
  return (
    "Ed.RegisterEventHandler(Ed.EVENT_DRIVE_STRAIN, 'if13')\n#drive strain event  \ndef if13():\n\tEd.RegisterEventHandler(Ed.EVENT_DRIVE_STRAIN, None)\nEd.TimeWait(150, Ed.TIME_MILLISECONDS)\n\tEd.ReadDriveLoad()\n\t" +
    Blockly.KukiLive.definitions_.globalVars
  );
};
Blockly.KukiLive.LEDs = {};
Blockly.KukiLive.leds_left = function (a) {
  a = a.getFieldValue("LEDS");
  return (
    "#left LED\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.LeftLed(Ed." +
    a +
    ")\n"
  );
};
Blockly.KukiLive.leds_right = function (a) {
  a = a.getFieldValue("LEDS");
  return (
    "#right LED\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.RightLed(Ed." +
    a +
    ")\n"
  );
};
Blockly.KukiLive.leds_send_message = function (a) {
  return (
    "#send IR data\nEd.SendIRData(" +
    Blockly.KukiLive.valueToCode(a, "MESSAGE", Blockly.KukiLive.ORDER_ATOMIC) +
    ")\n"
  );
};
Blockly.KukiLive.Math = {};
Blockly.KukiLive.math_angle = function (a) {
  a = parseInt(a.getFieldValue("NUM"));
  isNaN(a) && (a = 0);
  a < 0 && (a = 0);
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.math_angle_CC = function (a) {
  a = parseInt(a.getFieldValue("NUM"));
  isNaN(a) && (a = 0);
  a < 0 && (a = 0);
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.math_number = function (a) {
  a = parseInt(a.getFieldValue("NUM"));
  isNaN(a) && (a = 0);
  a < 0 && (a = 0);
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.math_whole_number = function (a) {
  a = parseInt(a.getFieldValue("NUM"));
  isNaN(a) && (a = 0);
  a < 0 && (a = 0);
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.math_positive_number = function (a) {
  a = parseFloat(a.getFieldValue("NUM"));
  isNaN(a) && (a = 0);
  a < 0 && (a = 0);
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.math_integer = function (a) {
  a = parseFloat(a.getFieldValue("NUM"));
  isNaN(a) && (a = 0);
  return [a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.Operators = {};
Blockly.KukiLive.operator_add = function (a) {
  var b = Blockly.KukiLive.valueToCode(a, "NUM1", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "NUM2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "+" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "+" + a + ")"
      : Number(b) + Number(a),
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_subtract = function (a) {
  var b = Blockly.KukiLive.valueToCode(a, "NUM1", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "NUM2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "-" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "-" + a + ")"
      : Number(b) - Number(a),
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_multiply = function (a) {
  var b = Blockly.KukiLive.valueToCode(a, "NUM1", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "NUM2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "*" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "*" + a + ")"
      : Number(b) * Number(a),
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_divide = function (a) {
  var b = Blockly.KukiLive.valueToCode(a, "NUM1", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "NUM2", Blockly.KukiLive.ORDER_ATOMIC);
  isNaN(Number(b))
    ? (b = "(" + b + "/" + a + ")")
    : isNaN(Number(a))
    ? (b = "(" + b + "/" + a + ")")
    : Number(a) != 0
    ? ((b = Math.round(Number(b) / Number(a))), isNaN(b) && (b = 0))
    : (b = 0);
  return [b, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.operator_random = function (a) {
  var b = Blockly.KukiLive.valueToCode(a, "FROM", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "TO", Blockly.KukiLive.ORDER_ATOMIC);
  return ["Ed.Random(" + b + "," + a + ")", Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.operator_abs = function (a) {
  return [
    "abs(" +
      Blockly.KukiLive.valueToCode(a, "NUM1", Blockly.KukiLive.ORDER_ATOMIC) +
      ")",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_lt = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "<" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "<" + a + ")"
      : Number(b) < Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_lt_equal = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "<=" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "<=" + a + ")"
      : Number(b) <= Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_equals = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "==" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "==" + a + ")"
      : Number(b) == Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_gt_equal = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + ">=" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + ">=" + a + ")"
      : Number(b) >= Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_gt = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + ">" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + ">" + a + ")"
      : Number(b) > Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_not_equals = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + b + "!=" + a + ")"
      : isNaN(Number(a))
      ? "(" + b + "!=" + a + ")"
      : Number(b) != Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_between = function (a) {
  var b = Blockly.KukiLive.valueToCode(
      a,
      "OPERAND1",
      Blockly.KukiLive.ORDER_ATOMIC
    ),
    c = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  a = Blockly.KukiLive.valueToCode(a, "OPERAND3", Blockly.KukiLive.ORDER_ATOMIC);
  return [
    isNaN(Number(b))
      ? "(" + c + "<=" + b + "<=" + a + ")"
      : isNaN(Number(c))
      ? "(" + c + "<=" + b + "<=" + a + ")"
      : isNaN(Number(a))
      ? "(" + c + "<=" + b + "<=" + a + ")"
      : Number(b) >= Number(c) && Number(b) <= Number(a)
      ? "True"
      : "False",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.operator_and = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  b == "" && (b = "False");
  a == "" && (a = "False");
  return [b + " and " + a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.operator_or = function (a) {
  var b = Blockly.KukiLive.valueToCode(
    a,
    "OPERAND1",
    Blockly.KukiLive.ORDER_ATOMIC
  );
  a = Blockly.KukiLive.valueToCode(a, "OPERAND2", Blockly.KukiLive.ORDER_ATOMIC);
  b == "" && (b = "False");
  a == "" && (a = "False");
  return [b + " or " + a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.operator_not = function (a) {
  a = Blockly.KukiLive.valueToCode(a, "OPERAND", Blockly.KukiLive.ORDER_ATOMIC);
  a == "" && (a = "False");
  return [" not " + a, Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.Procedures = {};
Blockly.KukiLive.procedures_definition = function (a) {
  var b = "#user function\n",
    c = Blockly.KukiLive.statementToCode(a, "custom_block");
  c = c.trimStart();
  a = Blockly.Procedures.allProcedureMutationNames(a.workspace).indexOf(c);
  return b + "def uf" + a + "():\n";
};
Blockly.KukiLive.procedures_prototype = function (a) {
  return a.getProcCode();
};
Blockly.KukiLive.procedures_call = function (a) {
  var b = "#calling user function \n",
    c = a.getProcCode();
  a = Blockly.Procedures.allProcedureMutationNames(a.workspace).indexOf(c);
  return b + ("uf" + a) + "()\n";
};
Blockly.KukiLive.Sensing = {};
Blockly.KukiLive.sensing_TurnLineTrackingLED = function (a) {
  a = a.getFieldValue("SWITCH");
  return (
    "#Turn line tracking LED\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.LineTrackerLed(" +
    a +
    ")\n"
  );
};
Blockly.KukiLive.sensing_TurnObstacleBeam = function (a) {
  a = a.getFieldValue("SWITCH");
  return (
    "#Turn Obstacle beam\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.ObstacleDetectionBeam(" +
    a +
    ")\n"
  );
};
Blockly.KukiLive.sensing_ClearSensor = function (a) {
  a = a.getFieldValue("SWITCH");
  var b = Blockly.KukiLive.definitions_.currentIndent;
  return (
    "#clearSensor\n" +
    b +
    "Ed.TimeWait(200,Ed.TIME_MILLISECONDS)\n" +
    b +
    a +
    "()\n"
  );
};
Blockly.KukiLive.sensing_ClapDetected = function (a) {
  return [
    "(Ed.ReadClapSensor()==Ed.CLAP_DETECTED)",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.sensing_ButtonPressed = function (a) {
  return [
    a.getFieldValue("BUTTON") == "ROUND"
      ? "(Ed.ReadRound()==1)"
      : "(Ed.ReadTriangle()==1)",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.sensing_Obstacle = function (a) {
  a = a.getFieldValue("OBS");
  return [
    a != "DETECTED"
      ? "(Ed.ReadObstacleDetection()==Ed.OBSTACLE_" + a + ")"
      : "(Ed.ReadObstacleDetection()!=Ed.OBSTACLE_NONE)",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.sensing_LineTracker = function (a) {
  return [
    "(Ed.ReadLineState()==Ed.LINE_ON_" + a.getFieldValue("SURFACE") + ")",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.sensing_remote_num = function (a) {
  return ["Ed.ReadRemote(False)", Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.sensing_remote_bool = function (a) {
  return [
    "(Ed.ReadRemote(False)==" + a.getFieldValue("IRCODE") + ")",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.sensing_IRMessage_Detected = function (a) {
  return ["(Ed.ReadIRData(False)!=0)", Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.sensing_IRmessage = function (a) {
  return ["Ed.ReadIRData()", Blockly.KukiLive.ORDER_ATOMIC];
};
Blockly.KukiLive.sensing_LightLevel = function (a) {
  return [
    "Ed.Read" + a.getFieldValue("Sensor") + "()",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.sensing_driveStrained = function (a) {
  return [
    "(Ed.ReadDriveLoad()==Ed.DRIVE_STRAINED)",
    Blockly.KukiLive.ORDER_ATOMIC,
  ];
};
Blockly.KukiLive.Sound = {};
Blockly.KukiLive.sound_beep = function (a) {
  return (
    "#BEEEEEEEEEEEP\n" +
    Blockly.KukiLive.definitions_.currentIndent +
    "Ed.PlayBeep()\nEd.TimeWait(125, Ed.TIME_MILLISECONDS)\n"
  );
};
Blockly.KukiLive.sound_play_note = function (a) {
  var b = a.getFieldValue("NOTEDURATION");
  var c = a.getFieldValue("NOTE"),
    d = a.getFieldValue("NOTETYPE"),
    e = Blockly.KukiLive.definitions_.currentIndent,
    f = "ncCdDefFgGaAbo".split("");
  a = a.nextConnection.targetBlock();
  var g = Blockly.KukiLive.definitions_.musicStackFlag;
  Blockly.KukiLive.definitions_.tempoSetUp == "" &&
    (Blockly.KukiLive.definitions_.tempoSetUp = "Ed.Tempo = Ed.TEMPO_MEDIUM \n");
  c != "r" &&
    (d == "SHARP"
      ? c != "o" && (c = f[f.indexOf(c) + 1])
      : d == "FLAT" && c != "n" && (c = f[f.indexOf(c) - 1]));
  Blockly.KukiLive.definitions_.inMusicBackGround
    ? (b = c + b)
    : g
    ? a != null
      ? a.type == "sound_play_note"
        ? ((Blockly.KukiLive.definitions_.musicStackString =
            Blockly.KukiLive.definitions_.musicStackString + c + b),
          (b = "#Play note stacked\n"))
        : ((b =
            "#Play note\n" +
            e +
            "Ed.PlayTune('" +
            Blockly.KukiLive.definitions_.musicStackString +
            c +
            b +
            "z')\n"),
          (b =
            b +
            e +
            "while Ed.ReadMusicEnd()==Ed.MUSIC_NOT_FINISHED:\n" +
            e +
            "\tpass\n"),
          (Blockly.KukiLive.definitions_.musicStackFlag = !1),
          (Blockly.KukiLive.definitions_.musicStackString = ""))
      : ((b =
          "#Play note\n" +
          e +
          "Ed.PlayTune('" +
          Blockly.KukiLive.definitions_.musicStackString +
          c +
          b +
          "z')\n"),
        (b =
          b +
          e +
          "while Ed.ReadMusicEnd()==Ed.MUSIC_NOT_FINISHED:\n" +
          e +
          "\tpass\n"),
        (Blockly.KukiLive.definitions_.musicStackFlag = !1),
        (Blockly.KukiLive.definitions_.musicStackString = ""))
    : a != null
    ? a.type == "sound_play_note"
      ? ((Blockly.KukiLive.definitions_.musicStackFlag = !0),
        (Blockly.KukiLive.definitions_.musicStackString = c + b),
        (b = "#start of stacked Play notes\n"))
      : (b =
          "#Play note\n" +
          e +
          "Ed.PlayTune('" +
          c +
          b +
          "z')\n" +
          e +
          "while Ed.ReadMusicEnd()==Ed.MUSIC_NOT_FINISHED:\n" +
          e +
          "\tpass\n")
    : (b =
        "#Play note\n" +
        e +
        "Ed.PlayTune('" +
        c +
        b +
        "z')\n" +
        e +
        "while Ed.ReadMusicEnd()==Ed.MUSIC_NOT_FINISHED:\n" +
        e +
        "\tpass\n");
  return b;
};
Blockly.KukiLive.sound_set_tempo = function (a) {
  a = a.getFieldValue("TEMPO");
  var b = Blockly.KukiLive.definitions_.currentIndent;
  Blockly.KukiLive.definitions_.tempoSetUp == "" &&
    (Blockly.KukiLive.definitions_.tempoSetUp = "Ed.Tempo = Ed.TEMPO_MEDIUM \n");
  return "#set tempo\n" + b + "Ed.Tempo = " + a + "\n";
};
Blockly.KukiLive.sound_PlayinBackground = function (a) {
  Blockly.KukiLive.definitions_.inMusicBackGround = !0;
  a = Blockly.KukiLive.statementToCode(a, "SUBSTACK");
  Blockly.KukiLive.definitions_.inMusicBackGround = !1;
  var b = Blockly.KukiLive.definitions_.currentIndent;
  a = a.trimStart();
  Blockly.KukiLive.definitions_.tempoSetUp == "" &&
    (Blockly.KukiLive.definitions_.tempoSetUp = "Ed.Tempo = Ed.TEMPO_MEDIUM \n");
  return "#PlayMusicInBackGround\n" + b + "Ed.PlayTune('" + a + "z')\n";
};


// GENRAL FUNCTIONS
function toTwoByteHex(value) {
  if (value < 0 || value > 65535) {
      console.error("Value out of range (0-65535)");
      return null;
  }

  let highByte = (value >> 8) & 0xFF;
  let lowByte = value & 0xFF;
  // console.log(`High Byte: 0x${highByte.toString(16).padStart(2, '0').toUpperCase()}, Low Byte: 0x${lowByte.toString(16).padStart(2, '0').toUpperCase()}`);
  return {
      high: highByte.toString(16).padStart(2, '0').toUpperCase(),
      low: lowByte.toString(16).padStart(2, '0').toUpperCase()
  };
}